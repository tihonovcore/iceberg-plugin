{
  parserClass="iceberg.parser.IcebergParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Iceberg"
  psiImplClassSuffix="Impl"
  psiPackage="iceberg.psi"
  psiImplPackage="iceberg.psi.impl"

  elementTypeHolderClass="iceberg.psi.IcebergTypes"
  elementTypeClass="iceberg.psi.IcebergElementType"
  tokenTypeClass="iceberg.psi.IcebergTokenType"
}

file
  ::= dependency* statement*

dependency
  ::= IMPORT ID (DOT ID)* SEMICOLON

statement
  ::= expression     SEMICOLON
    | printStatement SEMICOLON
    | defStatement   SEMICOLON
    | ifStatement
    | whileStatement
    | COMMENT

//statement
//  | functionDefinitionStatement
//  | classDefinitionStatement
//  | returnStatement SEMICOLON
//  | block
//  ;

printStatement
  ::= PRINT expression

defStatement
  ::= DEF ID
  ( COLON ID (ASSIGN expression)?
  | ASSIGN expression
  )

ifStatement
  ::= IF expression
      THEN statement
      (ELSE statement)?

whileStatement
  ::= WHILE expression THEN statement

//classDefinitionStatement
//  : CLASS name=ID OPEN_BRACE fieldDefinition* functionDefinitionStatement* CLOSE_BRACE
//  ;
//
//fieldDefinition
//  : DEF name=ID COLON type=ID (ASSIGN expression)?
//  ;
//
//functionDefinitionStatement
//  : FUN name=ID OPEN_PARENTHESIS parameters CLOSE_PARENTHESIS
//    (COLON returnType=ID)? block
//  ;
//
//parameters
//  : ((parameter COMMA)* parameter)?
//  ;
//
//parameter : name=ID COLON type=ID;
//
//functionCall
//  : name=ID OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS
//  ;
//
//arguments
//  : ((expression COMMA)* expression)?
//  ;
//
//returnStatement
//  : RETRUN expression?
//  ;
//
//block : OPEN_BRACE statement* CLOSE_BRACE;

//expression
//  : NEW className=ID
//  | NOT atom
//  | MINUS atom
//  | expression DOT  (ID | functionCall)
//  | left=expression (STAR | SLASH)      right=expression
//  | left=expression (PLUS | MINUS)      right=expression
//  | left=expression (LE | GE | LT | GT) right=expression
//  | left=expression (EQ | NEQ)          right=expression
//  | left=expression AND                 right=expression
//  | left=expression OR                  right=expression
//  | left=expression ASSIGN              right=expression
//  | atom
//  ;

//atom
//  : OPEN_PARENTHESIS expression CLOSE_PARENTHESIS
//  | functionCall
//  | NUMBER
//  | FALSE
//  | TRUE
//  | STRING
//  | ID
//  | THIS
//  ;

expression               ::= logicalOrExpression      (ASSIGN logicalOrExpression)?
logicalOrExpression      ::= logicalAndExpression     (OR logicalAndExpression)*
logicalAndExpression     ::= equalityExpression       (AND equalityExpression)*
equalityExpression       ::= relationalExpression     ((EQ | NEQ) relationalExpression)*
relationalExpression     ::= additiveExpression       ((LT | LE | GT | GE) additiveExpression)*
additiveExpression       ::= multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*
multiplicativeExpression ::= memberAccessExpression   ((STAR | SLASH) memberAccessExpression)*
memberAccessExpression   ::= unaryExpression //(DOT (ID | functionCall))*
//unaryExpression
//  ::= (NEW ID)
//    | (NOT unaryExpression)
//    | (MINUS unaryExpression)
//    | atom
//    ;
unaryExpression          ::= atom

atom ::= NUMBER|FALSE|TRUE|NULL|COMMENT|ID