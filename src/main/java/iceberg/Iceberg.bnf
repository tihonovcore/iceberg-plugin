{
  parserClass="iceberg.parser.IcebergParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Iceberg"
  psiImplClassSuffix="Impl"
  psiPackage="iceberg.psi"
  psiImplPackage="iceberg.psi.impl"

  elementTypeHolderClass="iceberg.psi.IcebergTypes"
  elementTypeClass="iceberg.psi.IcebergElementType"
  tokenTypeClass="iceberg.psi.IcebergTokenType"
}

file
  ::= dependency* statement*

dependency
  ::= IMPORT ID (DOT ID)* SEMICOLON

statement
  ::= expression      SEMICOLON
    | printStatement  SEMICOLON
    | defStatement    SEMICOLON
    | returnStatement SEMICOLON
    | ifStatement
    | whileStatement
    | functionDefinitionStatement
    | classDefinitionStatement
    | block
    | COMMENT

printStatement
  ::= PRINT expression

defStatement
  ::= DEF ID
  ( COLON ID (ASSIGN expression)?
  | ASSIGN expression
  )

returnStatement ::= RETURN expression?

ifStatement
  ::= IF expression
      THEN statement
      (ELSE statement)?

whileStatement
  ::= WHILE expression THEN statement

classDefinitionStatement
  ::= CLASS ID OPEN_BRACE fieldDefinition* functionDefinitionStatement* CLOSE_BRACE

fieldDefinition
  ::= DEF ID COLON ID (ASSIGN expression)?

functionDefinitionStatement
  ::= FUN ID OPEN_PARENTHESIS parameters CLOSE_PARENTHESIS (COLON ID)? block

parameters ::= ((parameter COMMA)* parameter)?
parameter  ::= ID COLON ID;

functionCall ::= ID OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS
arguments    ::= ((expression COMMA)* expression)?

block ::= OPEN_BRACE statement* CLOSE_BRACE

expression               ::= logicalOrExpression      (ASSIGN logicalOrExpression)?
logicalOrExpression      ::= logicalAndExpression     (OR logicalAndExpression)*
logicalAndExpression     ::= equalityExpression       (AND equalityExpression)*
equalityExpression       ::= relationalExpression     ((EQ | NEQ) relationalExpression)*
relationalExpression     ::= additiveExpression       ((LT | LE | GT | GE) additiveExpression)*
additiveExpression       ::= multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*
multiplicativeExpression ::= memberAccessExpression   ((STAR | SLASH) memberAccessExpression)*
memberAccessExpression   ::= unaryExpression          (DOT ID (OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS)?)*

unaryExpression
  ::= (NEW ID)
    | (NOT unaryExpression)
    | (MINUS unaryExpression)
    | atom

atom
  ::= OPEN_PARENTHESIS expression CLOSE_PARENTHESIS
    | functionCall
    | NUMBER
    | FALSE
    | TRUE
    | QUOTES (CHAR|VALID_ESCAPE|INVALID_ESCAPE)* QUOTES
    | NULL
    | ID
    | THIS
